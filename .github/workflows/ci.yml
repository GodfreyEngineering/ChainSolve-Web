name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

# Cancel in-progress runs on the same ref so new pushes don't queue behind stale jobs.
concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ── Job 1: Rust tests ──────────────────────────────────────────────────────
  # Pure cargo test — no wasm-pack, no Node.  Runs in parallel with node_checks.
  rust_tests:
    name: Rust tests
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      # Swatinem/rust-cache caches ~/.cargo/registry + ~/.cargo/git + target/
      # keyed on Cargo.lock — better hit rate than the manual actions/cache setup.
      - uses: Swatinem/rust-cache@v2

      - name: Rust tests
        run: cargo test --workspace

  # ── Job 2: WASM build + Node checks + Vite build ──────────────────────────
  # Runs in parallel with rust_tests.  Produces the dist/ artifact consumed by
  # e2e_smoke and deploy.
  node_checks:
    name: WASM build + Node checks + Build
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - uses: Swatinem/rust-cache@v2

      - name: Install wasm-pack
        run: curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

      - name: Build WASM
        run: wasm-pack build crates/engine-wasm --target web --release

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - run: npm ci

      - name: Typecheck (app)
        run: npx tsc -b --noEmit

      - name: Typecheck (functions)
        run: npm run typecheck:functions

      - name: Lint
        run: npm run lint

      - name: Format check
        run: npm run format:check

      - name: Build
        run: npx tsc -b && npx vite build
        env:
          # Placeholder credentials baked into the e2e artifact.  These allow
          # the app to boot (React mounts, WASM loads) without real Supabase
          # credentials.  Supabase network calls fail silently to a non-existent
          # host — that is fine because smoke tests do not exercise auth.
          # The deploy job rebuilds with real credentials from secrets.
          VITE_SUPABASE_URL: https://placeholder.supabase.co
          VITE_SUPABASE_ANON_KEY: placeholder
          # Tells src/lib/supabase.ts not to throw CONFIG_INVALID for placeholder
          # credentials.  MUST NOT be set in the deploy job.
          VITE_IS_CI_BUILD: 'true'

      - name: Upload WASM pkg artifact
        # Uploaded separately so the deploy job can reuse the compiled WASM
        # without re-running wasm-pack (saves ~2-3 min on the deploy job).
        uses: actions/upload-artifact@v4
        with:
          name: wasm-pkg
          path: crates/engine-wasm/pkg/
          retention-days: 1

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist/
          retention-days: 7

  # ── Job 3: E2E smoke (Playwright) ─────────────────────────────────────────
  # Runs only the `smoke` project (smoke.spec.ts: 8 tests).
  # One WASM compilation for the engine-ready test; all others are instant.
  # Target: < 90 s on warm runners.
  #
  # Skipped on PRs — PRs get typecheck + lint + build as the gate.
  # Playwright only runs on direct pushes to main (where deploy follows).
  e2e_smoke:
    name: E2E smoke
    runs-on: ubuntu-latest
    needs: [node_checks]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - run: npm ci

      - name: Download dist artifact
        uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist

      - name: Sanity-check dist (WASM must be present)
        # Fail fast before spending time on browser install if the build was
        # missing or the WASM file was not included in the artifact.
        run: |
          echo "=== dist/assets/ ==="
          ls dist/assets/
          count=$(find dist/assets -name '*.wasm' | wc -l)
          if [ "$count" -eq 0 ]; then
            echo "ERROR: no .wasm file found in dist/assets/ — Build step may have failed"
            exit 1
          fi
          echo "Found $count WASM file(s) — OK"

      - name: Cache Playwright browsers
        uses: actions/cache@v4
        with:
          path: ~/.cache/ms-playwright
          key: playwright-${{ runner.os }}-${{ hashFiles('package-lock.json') }}

      - name: Install Playwright browsers
        # Always run for system deps; browser binary is served from cache if present.
        run: npx playwright install --with-deps chromium

      - name: E2E smoke tests
        run: npx playwright test --project=smoke

      - name: Upload Playwright report
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-report
          path: |
            test-results/
            playwright-report/
          retention-days: 7

  # ── Job 4: Deploy → Cloudflare Pages ──────────────────────────────────────
  # Runs only on direct pushes to main, and only after all checks pass.
  #
  # The e2e artifact (dist/) was built with placeholder Supabase credentials so
  # smoke tests can boot the app without real auth.  This job downloads the
  # compiled WASM pkg (no Rust/wasm-pack needed) and re-runs only the Vite build
  # with real credentials from GitHub secrets — producing a correct production
  # bundle.  Required secrets:
  #   VITE_SUPABASE_URL       — Supabase project URL (public anon credential)
  #   VITE_SUPABASE_ANON_KEY  — Supabase anon key   (public anon credential)
  #   CLOUDFLARE_API_TOKEN
  #   CLOUDFLARE_ACCOUNT_ID
  deploy:
    name: Deploy → Cloudflare Pages
    runs-on: ubuntu-latest
    needs: [rust_tests, node_checks, e2e_smoke]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'

    steps:
      - uses: actions/checkout@v4
        # Checkout is required so the `functions/` directory is present.
        # Wrangler compiles Pages Functions at deploy time using its own bundler.

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - run: npm ci
        # node_modules must exist so wrangler's esbuild can resolve imports
        # inside functions/ (e.g. `stripe`, `@supabase/supabase-js`).

      - name: Download WASM pkg artifact
        # Reuse the WASM compiled by node_checks — no need to re-run wasm-pack.
        uses: actions/download-artifact@v4
        with:
          name: wasm-pkg
          path: crates/engine-wasm/pkg

      - name: Validate production secrets
        # Fail fast if VITE_SUPABASE_* secrets are absent or still placeholder.
        # When a GitHub Secret is not configured, Actions substitutes "".
        # When a secret was accidentally set to the placeholder value, catch that too.
        run: |
          fail=0
          if [ -z "$VITE_SUPABASE_URL" ]; then
            echo "::error::VITE_SUPABASE_URL secret is not set in GitHub Secrets"
            fail=1
          elif [ "$VITE_SUPABASE_URL" = "https://placeholder.supabase.co" ]; then
            echo "::error::VITE_SUPABASE_URL is still set to the placeholder value"
            fail=1
          fi
          if [ -z "$VITE_SUPABASE_ANON_KEY" ]; then
            echo "::error::VITE_SUPABASE_ANON_KEY secret is not set in GitHub Secrets"
            fail=1
          elif [ "$VITE_SUPABASE_ANON_KEY" = "placeholder" ]; then
            echo "::error::VITE_SUPABASE_ANON_KEY is still set to the placeholder value"
            fail=1
          fi
          if [ "$fail" -eq 1 ]; then
            echo "Add secrets at: GitHub → Settings → Secrets and variables → Actions → Repository secrets"
            exit 1
          fi
          echo "✓ VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY are set to non-placeholder values"
        env:
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}

      - name: Build (production — real Supabase credentials)
        # Re-run only the Vite build (TypeScript + asset bundling).  The WASM
        # binary is already in crates/engine-wasm/pkg/ from the artifact above.
        run: npx tsc -b && npx vite build
        env:
          VITE_SUPABASE_URL: ${{ secrets.VITE_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}

      - name: Guard — no placeholder Supabase URL in production bundle
        # Belt-and-suspenders: if the URL secret was absent or placeholder, Vite
        # bakes that string into the JS bundle.  Catch it here before deploying.
        run: |
          if grep -rq "placeholder\.supabase\.co" dist/ --include="*.js" --include="*.html" 2>/dev/null; then
            echo "::error::Found 'placeholder.supabase.co' in production bundle"
            echo "VITE_SUPABASE_URL was not set or was the placeholder value."
            echo "Set the real URL in GitHub Secrets and re-run the deploy job."
            exit 1
          fi
          echo "✓ No placeholder Supabase URL in production bundle"

      - name: Deploy to Cloudflare Pages
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          # Deploy static assets from dist/ as production (--branch=main).
          # Wrangler picks up functions/ from the working directory automatically.
          # wrangler.jsonc provides the compatibility_date.
          command: pages deploy dist --project-name=chainsolve-web --branch=main
